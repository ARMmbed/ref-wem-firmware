diff --git a/mbed-os.lib b/mbed-os.lib
index 7700c1a..36fcb21 100644
--- a/mbed-os.lib
+++ b/mbed-os.lib
@@ -1 +1 @@
-https://github.com/ARMmbed/mbed-os/#42be5c01a7f91292d5e27124ad9584236025f6ab
+https://github.com/ARMmbed/mbed-os/#5fff7e1daeb395aa3d1ecf3f9ec3f4fead3de0c2
diff --git a/mbed_app.json b/mbed_app.json
index 03a3f11..7942fce 100755
--- a/mbed_app.json
+++ b/mbed_app.json
@@ -35,9 +35,9 @@
             "mbed-client-pal.update-active-metadata-header-offset": "0x08020000"
         },
         "UBLOX_EVK_ODIN_W2": {
-            "firmware_metadata_header_address": "0x08020000",
+            "firmware_metadata_header_address": "0x08040000",
             "firmware_metadata_header_size": "0x400",
-            "mbed-client-pal.update-active-metadata-header-offset": "0x08020000"
+            "mbed-client-pal.update-active-metadata-header-offset": "0x08040000"
         }
     }
 }
diff --git a/sd-driver.lib b/sd-driver.lib
index 0cac279..665cd65 100644
--- a/sd-driver.lib
+++ b/sd-driver.lib
@@ -1 +1 @@
-https://github.com/ARMmbed/sd-driver/#2dc0da56c3115bd925e254ab38ae3babf26b3169
+https://github.com/ARMmbed/sd-driver/#efc6bbc46ef264925f5e771a3563638707c6875b
diff --git a/source/active_application.cpp b/source/active_application.cpp
index 962a7a3..20322af 100755
--- a/source/active_application.cpp
+++ b/source/active_application.cpp
@@ -16,6 +16,7 @@
 #define __STDC_FORMAT_MACROS
 #endif
 
+#include "fota.h"
 #include "active_application.h"
 #include "bootloader_common.h"
 #include "update-client-extensions/arm_uc_firmware_extensions.h"
@@ -26,6 +27,9 @@
 
 static FlashIAP flash;
 
+#define STR_SUCCESS "SUCCESS"
+#define STR_FAIL    "FAIL"
+
 bool activeStorageInit(void)
 {
     int rc = flash.init();
@@ -67,6 +71,13 @@ bool readActiveFirmwareHeader(FirmwareHeader_t* headerP)
         uint32_t calculatedChecksum = pal_crc32((const uint8_t*) headerP,
                                                 sizeof(FirmwareHeader_t));
 
+        tr_info("    magic   : 0x%08" PRIX32 "\r\n", headerP->magic);
+        tr_info("    version : %lu\r\n", headerP->version);
+        tr_info("    size    : %lu\r\n", headerP->totalSize);
+        tr_info("    version : %llu\r\n", headerP->firmwareVersion);
+        tr_info("    stored checksum: 0x%08" PRIX32 "\r\n", storedChecksum);
+        tr_info("    actual checksum: 0x%08" PRIX32 "\r\n", calculatedChecksum);
+
         if (storedChecksum == calculatedChecksum)
         {
             tr_debug("active firmware header valid\r\n");
@@ -144,6 +155,8 @@ int checkActiveApplication(palImageHeaderDetails_t* details)
 
 #if defined(SHOW_PROGRESS_BAR) && SHOW_PROGRESS_BAR == 1
                 printProgress(header.totalSize - remaining, header.totalSize);
+                fota::printProgress(header.totalSize - remaining, header.totalSize,
+                        "CHK Active");
 #endif
             }
 
@@ -187,6 +200,7 @@ bool eraseActiveFirmware(uint32_t firmwareSize)
     tr_debug("eraseActiveFirmware\r\n");
 
     /* get sector size of where the new firmware would end */
+    fota::printProgress(0, 100, "Erasing");
     uint32_t lastSectorSize =
         flash.get_sector_size(MBED_CONF_APP_FIRMWARE_METADATA_HEADER_ADDRESS +
                               MBED_CONF_APP_FIRMWARE_METADATA_HEADER_SIZE +
@@ -205,9 +219,12 @@ bool eraseActiveFirmware(uint32_t firmwareSize)
              (uint32_t) MBED_CONF_APP_FIRMWARE_METADATA_HEADER_ADDRESS + sizeRoundedUp);
 
     /* erase flash to make place for new application */
+    fota::printProgress(33, 100, "Erasing");
     int result = flash.erase(MBED_CONF_APP_FIRMWARE_METADATA_HEADER_ADDRESS,
                              sizeRoundedUp);
 
+    fota::printProgress(100, 100, "Erasing");
+
     return (result == 0);
 }
 
@@ -217,6 +234,7 @@ bool writeActiveFirmwareHeader(palImageHeaderDetails_t* imageDetails)
 
     bool result = false;
 
+    fota::printProgress(0, 100, "Write HDR");
     if (imageDetails)
     {
         FirmwareHeader_t header = { 0 };
@@ -249,10 +267,13 @@ bool writeActiveFirmwareHeader(palImageHeaderDetails_t* imageDetails)
         memcpy(buffer, &header, sizeof(FirmwareHeader_t));
 
         /* write header using FlashIAP API */
+        fota::printProgress(33, 100, "Write HDR");
         int ret = flash.program(buffer,
                                 MBED_CONF_APP_FIRMWARE_METADATA_HEADER_ADDRESS,
                                 programSize);
 
+        fota::printProgress(100, 100, "Write HDR");
+
         result = (ret == 0);
     }
 
@@ -265,6 +286,7 @@ bool writeActiveFirmware(palImageId_t index, palImageHeaderDetails_t* imageDetai
 
     bool result = false;
 
+    fota::printProgress(0, 100, "Write FW");
     if (imageDetails)
     {
         const uint32_t pageSize = flash.get_page_size();
@@ -324,6 +346,8 @@ bool writeActiveFirmware(palImageId_t index, palImageHeaderDetails_t* imageDetai
 
 #if defined(SHOW_PROGRESS_BAR) && SHOW_PROGRESS_BAR == 1
                     printProgress(offset + programOffset, imageDetails->imageSize);
+                    fota::printProgress(offset + programOffset, imageDetails->imageSize,
+                            "Write FW");
 #endif
                 }
 
@@ -342,6 +366,8 @@ bool writeActiveFirmware(palImageId_t index, palImageHeaderDetails_t* imageDetai
             }
         }
 
+        fota::printProgress(100, 100, "Write FW");
+
         result = (retval == 0);
     }
 
@@ -362,7 +388,10 @@ bool copyStoredApplication(palImageId_t index,
     /* Step 1. Erase active application                                      */
     /*************************************************************************/
 
+    fota::setStep(2, 5);
+    tr_info("erasing active firmware...\r\n");
     result = eraseActiveFirmware(details->imageSize);
+    tr_info("...%s\r\n", (result ? STR_SUCCESS : STR_FAIL));
 
     /*************************************************************************/
     /* Step 2. Write header                                                  */
@@ -370,7 +399,10 @@ bool copyStoredApplication(palImageId_t index,
 
     if (result)
     {
+        fota::setStep(3, 5);
+        tr_info("writing new firmware header...\r\n");
         result = writeActiveFirmwareHeader(details);
+        tr_info("...%s\r\n", (result ? STR_SUCCESS : STR_FAIL));
     }
 
     /*************************************************************************/
@@ -379,7 +411,10 @@ bool copyStoredApplication(palImageId_t index,
 
     if (result)
     {
+        fota::setStep(4, 5);
+        tr_info("writing new firmware...\r\n");
         result = writeActiveFirmware(index, details);
+        tr_info("...%s\r\n", (result ? STR_SUCCESS : STR_FAIL));
     }
 
     /*************************************************************************/
@@ -390,10 +425,16 @@ bool copyStoredApplication(palImageId_t index,
     {
         tr_info("Verify new active firmware:\r\n");
 
+        fota::setStep(5, 5);
         int recheck = checkActiveApplication(details);
 
         result = (recheck == RESULT_SUCCESS);
     }
 
+    if (!result) {
+        fota::setStep(0, 0);
+        fota::printProgress(0, 1, "UPDATE FAILED!");
+    }
+
     return result;
 }
diff --git a/source/fota.cpp b/source/fota.cpp
new file mode 100644
index 0000000..ca6cab2
--- /dev/null
+++ b/source/fota.cpp
@@ -0,0 +1,60 @@
+#include "fota.h"
+
+/* Since this structure needs to be accessed by both the setStep
+ * and printProgress calls we statically declare it here.
+ *
+ * @param current The step number in progress.
+ * @param total The number of total steps.
+ */
+static struct {
+    uint32_t current;
+    uint32_t total;
+} steps = { 0, 0 };
+
+/** Wrapper function for obtaining the active display manager. There is
+ * only a single occurring instance of this at any given time.
+ *
+ * @return Returns a pointer to the active display manager.
+ */
+DisplayMan *fota::getDisplayManager(void)
+{
+    static DisplayMan display;
+    display.init("FOTA");
+    display.set_downloading();
+    display.refresh();
+    return &display;
+}
+
+/** Prints the progress of the current activity to the LCD using the
+ * current active display manager.
+ *
+ * @param progress The current progress being made.
+ * @param total The total, or maximum, value of progress to be made.
+ * @param msg An optional message to be displayed (default '...')
+ */
+void fota::printProgress(uint32_t progress, uint32_t total, const char *msg)
+{
+    char buf[17] = {0}; /* assume 16 character LCD screen */
+
+    if (0 != steps.total && steps.current <= steps.total) {
+        snprintf(buf, sizeof(buf) - 1, "[%lu/%lu] %s", steps.current, steps.total, msg);
+    } else {
+        snprintf(buf, sizeof(buf) - 1, "%s", msg);
+    }
+
+    DisplayMan *display = getDisplayManager();
+    display->set_progress(buf, progress, total);
+    display->refresh();
+}
+
+/** Sets the current step number and the total number of steps to be prefixed
+ * to the printProgress message.
+ *
+ * @param current The step number in progress.
+ * @param total The number of total steps.
+ */
+void fota::setStep(uint32_t current, uint32_t total)
+{
+    steps.current = current;
+    steps.total = total;
+}
diff --git a/source/fota.h b/source/fota.h
new file mode 100644
index 0000000..5ad60b3
--- /dev/null
+++ b/source/fota.h
@@ -0,0 +1,34 @@
+#ifndef __BOOTLOADER_FOTA_H__
+#define __BOOTLOADER_FOTA_H__
+
+#include "displayman.h"
+
+namespace fota {
+
+/** Wrapper function for obtaining the active display manager. There is
+ * only a single occurring instance of this at any given time.
+ *
+ * @return Returns a pointer to the active display manager.
+ */
+DisplayMan *getDisplayManager(void);
+
+/** Prints the progress of the current activity to the LCD using the
+ * current active display manager.
+ *
+ * @param progress The current progress being made.
+ * @param total The total, or maximum, value of progress to be made.
+ * @param msg An optional message to be displayed (default '...')
+ */
+void printProgress(uint32_t progress, uint32_t total, const char *msg = "...");
+
+/** Sets the current step number and the total number of steps to be prefixed
+ * to the printProgress message.
+ *
+ * @param current The step number in progress.
+ * @param total The number of total steps.
+ */
+void setStep(uint32_t current, uint32_t total);
+
+} // end namespace fota
+
+#endif
diff --git a/source/main.cpp b/source/main.cpp
index b66a63f..9814796 100755
--- a/source/main.cpp
+++ b/source/main.cpp
@@ -37,8 +37,19 @@
 #include "firmware_update_test.h"
 #endif
 
+#include <SDBlockDevice.h>
+
+extern SDBlockDevice sd;
+
 int main(void)
 {
+    int ret;
+
+    ret = sd.init();
+    if (ret != BD_ERROR_OK) {
+        tr_error("ERROR: sd init failed: %d\n", ret);
+    }
+
     /* Use malloc to allocate uint64_t version number on the heap */
     heapVersion = (uint64_t*) malloc(sizeof(uint64_t));
     bootCounter = (uint8_t*) malloc(1);
diff --git a/source/upgrade.cpp b/source/upgrade.cpp
index 1b0162d..d7d1ebf 100755
--- a/source/upgrade.cpp
+++ b/source/upgrade.cpp
@@ -16,6 +16,7 @@
 #define __STDC_FORMAT_MACROS
 #endif
 
+#include "fota.h"
 #include "upgrade.h"
 
 #include "pal.h"
@@ -107,6 +108,8 @@ bool checkStoredApplication(palImageId_t source,
 
 #if defined(SHOW_PROGRESS_BAR) && SHOW_PROGRESS_BAR == 1
             printProgress(offset, details->imageSize);
+            fota::printProgress(offset, details->imageSize,
+                    "CHK Flash");
 #endif
         }
 
@@ -247,7 +250,8 @@ bool upgradeApplicationFromStorage(void)
         (localCounter < MAX_BOOT_RETRIES))
     {
         printSHA256(imageDetails.hash.buffer);
-        tr_info("Version: %" PRIu64 "\r\n", imageDetails.version);
+        tr_info("Active firmware version: %" PRIu64 "\r\n",
+                imageDetails.version);
 
         /* mark active firmware as usable */
         activeFirmwareValid = true;
@@ -296,6 +300,8 @@ bool upgradeApplicationFromStorage(void)
                     (*heapVersion != imageDetails.version);
             }
 #endif
+            tr_info("Slot %" PRIu32 " firmware version: %" PRIu64 "\r\n",
+                    index, imageDetails.version);
 
             /* Only hash check firmwares with higher version number than the
                active image and with a different hash. This prevents rollbacks
@@ -310,6 +316,7 @@ bool upgradeApplicationFromStorage(void)
                         index);
 
                 /* Validate candidate firmware body. */
+                fota::setStep(1, 5);
                 bool firmwareValid = checkStoredApplication(index,
                                                             &imageDetails);
 
@@ -317,7 +324,6 @@ bool upgradeApplicationFromStorage(void)
                 {
                     /* Integrity check passed */
                     printSHA256(imageDetails.hash.buffer);
-                    tr_info("Version: %" PRIu64 "\r\n", imageDetails.version);
 
                     /* Update best candidate information */
                     bestStoredFirmwareIndex = index;
@@ -336,12 +342,10 @@ bool upgradeApplicationFromStorage(void)
             }
             else
             {
-                tr_info("Slot %" PRIu32 " firmware is of older date\r\n",
-                        index);
+                tr_info("Slot %" PRIu32 " firmware is older\r\n", index);
                 /* do not print HMAC version
                 printSHA256(imageDetails.hash.buffer);
                 */
-                tr_info("Version: %" PRIu64 "\r\n", imageDetails.version);
             }
 
         }
diff --git a/tools/combine_bootloader_with_app.py b/tools/combine_bootloader_with_app.py
new file mode 100755
index 0000000..5df0ede
--- /dev/null
+++ b/tools/combine_bootloader_with_app.py
@@ -0,0 +1,133 @@
+#!/usr/bin/env python
+
+from os import path
+import hashlib, zlib, struct
+import time
+
+'''
+define FIRMWARE_HEADER_MAGIC   0x5a51b3d4UL
+define FIRMWARE_HEADER_VERSION 1
+typedef struct FirmwareHeader {
+    uint32_t magic;                         /** Metadata-header specific magic code */
+    uint32_t version;                       /** Revision number for this generic metadata header. */
+    uint32_t checksum;                      /** A checksum of this header. This field should be considered to be zeroed out for
+                                             *  the sake of computing the checksum. */
+    uint32_t totalSize;                     /** Total space (in bytes) occupied by the firmware BLOB. */
+    uint64_t firmwareVersion;               /** Version number for the accompanying firmware. Larger numbers imply more preferred (recent)
+                                             *  versions. This defines the selection order when multiple versions are available. */
+    uint8_t  firmwareSHA256[SIZEOF_SHA256]; /** A SHA-2 using a block-size of 256-bits of the firmware, including any firmware-padding. */
+} FirmwareHeader_t;
+'''
+
+# define defaults to go into the metadata header
+SIZEOF_SHA256 = 256/8
+FIRMWARE_HEADER_MAGIC = 0x5a51b3d4
+FIRMWARE_HEADER_VERSION = 1
+FirmwareHeader_t = "4IQ{}s".format(SIZEOF_SHA256) # 4*unsigned int, 1*unsigned long long, 1*bytes
+
+def create_header(app_blob, firmwareVersion):
+    # calculate the hash of the application
+    firmwareSHA256 = hashlib.sha256(app_blob)
+
+    # calculate the total size which is defined as the application size + metadata header
+    totalSize = len(app_blob)
+
+    print ('imageSize:    {}'.format(totalSize))
+    print ('imageHash:    {}'.format(''.join(['{:0>2x}'.format(ord(c)) for c in firmwareSHA256.digest()])))
+    print ('imageversion: {}'.format(firmwareVersion))
+
+    # set checksum to zero and calculate the checksum of the header
+    checksum = 0
+    FirmwareHeader = struct.pack(FirmwareHeader_t,
+                                    FIRMWARE_HEADER_MAGIC,
+                                    FIRMWARE_HEADER_VERSION,
+                                    checksum,
+                                    totalSize,
+                                    firmwareVersion,
+                                    firmwareSHA256.digest())
+    checksum = zlib.crc32(FirmwareHeader) & 0xffffffff
+
+    # Pack the data into a binary blob
+    FirmwareHeader = struct.pack(FirmwareHeader_t,
+                                    FIRMWARE_HEADER_MAGIC,
+                                    FIRMWARE_HEADER_VERSION,
+                                    checksum,
+                                    totalSize,
+                                    firmwareVersion,
+                                    firmwareSHA256.digest())
+
+    return FirmwareHeader
+
+
+def combine(bootloader_blob, app_blob, app_offset, hdr_offset, output, version):
+
+    # create header to go with the application binary
+    FirmwareHeader = create_header(app_blob, version)
+
+    # write the bootloader first
+    offset = 0
+    output.write(bootloader_blob)
+    offset += len(bootloader_blob)
+
+    # write the padding between bootloader and firmware header
+    output.write(b'\00' * (hdr_offset - offset))
+    offset += (hdr_offset - offset)
+
+    # write firmware header
+    output.write(FirmwareHeader)
+    offset += len(FirmwareHeader)
+
+    # write padding between header and application
+    output.write(b'\00' * (app_offset - offset))
+
+    # write the application
+    output.write(app_blob)
+
+
+if __name__ == '__main__':
+    import argparse
+
+    parser = argparse.ArgumentParser(
+        description='Combine bootloader with application adding metadata header.')
+
+    def offset_arg(s):
+        if s.startswith('0x'):
+            return int(s, 16)
+        else:
+            return int(s)
+
+    # specify arguments
+    parser.add_argument('-b', '--bootloader',    type=argparse.FileType('rb'), required=True,
+                        help='path to the bootloader binary')
+    parser.add_argument('-a', '--app',           type=argparse.FileType('rb'), required=True,
+                        help='path to application binary')
+    parser.add_argument('-c', '--app-offset',    type=offset_arg,              required=True,
+                        help='offset of the application')
+    parser.add_argument('-d', '--header-offset', type=offset_arg,              required=True,
+                        help='offset of the firmware metadata header')
+    parser.add_argument('-o', '--output',        type=argparse.FileType('wb'), required=True,
+                        help='output combined file path')
+    parser.add_argument('-s', '--set-version',   type=int,                     required=False,
+                        help='set version number', default=int(time.time()))
+
+    # workaround for http://bugs.python.org/issue9694
+    parser._optionals.title = "arguments"
+
+    # get and validate arguments
+    args = parser.parse_args()
+
+    # read the contents of bootloader and application binaries into buffers
+    bootloader_blob = args.bootloader.read()
+    args.bootloader.close()
+    app_blob = args.app.read()
+    args.app.close()
+
+    # combine applicaiton and bootloader adding metadata info
+    combine(bootloader_blob, app_blob, args.app_offset, args.header_offset, args.output, args.set_version)
+
+    # close output file
+    output_fn = path.abspath(args.output.name)
+    args.output.close()
+
+    # print the output file path
+    print 'Combined binary:', output_fn
